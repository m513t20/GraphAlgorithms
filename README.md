# GraphAlgorithms
C# Custom Graph algorithms

1. Алгоритм Дейкстры
2. Муравьиный алгоритм
3. альфа-бета

    

# Алгоритм Дейкстры
            Deixtra\Graph\Tools\Dijcstra.cs
брал код который у был в презентации, только перевел его на C#
используется очеред с приоритетом, где приоритет - длинна пути
# Муравьинный алгоритм
            Deixtra\Graph\Tools\AntAlgoritm
Сотоит и следующих структур:
* ant - муравей. у него есть параметры альфа и бетта, стартовая вершина и пройденный им путь. Из методов - выбрать следующую вершину
* * path - структура для пути содержит его длинну и список вершин
* antAlgoritmSolver - решатель для муравьинного алгоритма. Он содержит в себе граф (отдельный класс), список того какое количество муравьев с каким альфа-бета должно быть в колонии. Из публичных методов у него есть solve() - нчать решение муравьиным алгоритмом
* * antBlueprint - чертеж муравья - какие альфа, бета и какая численность

## как работает решение?
1. Проверяем наличие гамильтонова цикла в неориентированном графе (достаточное и необходимое условие)
2. создается колония по чертежам муравьев
3. далее в цикле перебираем каждого муравья в колонии и им проходим по графу (выбор вершины я сдавал - нормализуем привлекательность через деление на их сумму - ребра длинной меньше 0 не существует тк в классе графа добавлена проверка на длинну пути)
4. если муравей прошел весь цикл сохраняем егр
5. если путь минимален - обновляем кратчайший путь
6. испаряем феромоны
7. обновляем феромоны на прошедших цикл муравьях

# Альфа-бета
сдавал - 4 в ряд

алгоритм просчитывает на N ходов вперед (где N - глубина) и смотрит какой исход лучше, при этом сразу же отсекает через альфа-бета невыгодные ветки